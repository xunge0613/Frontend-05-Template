# 学习笔记

> ps：这周内容感觉比上周更深一些，加上加班比较多，周六通宵加了个班，所以笔记记的不够详细，立个 flag 后续再好好补一下

## 本周目标

> 讲完剩下的几个字符串分析算法

## 第一小节

### 五种字符串模式匹配

- 字典树：大量高重复字符串的存储与分析
  - 用途：精确匹配、海量处理
  - eg 1：处理一亿个字符串中，频率前 50 的字符串
  - eg 2：搜索关键词
- KMP：在长字符串里找模式
  - 说明：不是完整的字符串匹配算法
  - 用途：检查长字符串里里面有没有一个短字符串的部分
  - 区别：
    - 字典树：检查两个字符串是否完全匹配
    - KMP：检查一个字符串是否是另一个字符串的部分
  - 特点：
    - 复杂度 m + n
- Wildcard：带通配符的字符串模式
  - 说明：在 KMP 的基础上加了通配符（?、\*），可以理解为弱一点的正则表达式
  - 用途：文件查找
  - 区别：不同于正则，Wildcard 可以在 O(n) 或者 O(m + n) 的时间复杂度处理掉，利用了贪心算法
- 正则：字符串通用模式匹配
  - 说明：一般需要用到回溯，是字符串匹配的终极版本
- 状态机：通用的字符串分析
  - 说明：比正则更强大（理论上，正则和有限状态机是完全等价的）
  - 功能：有限状态机里可以嵌代码，可以对字符串做额外处理
  - 代价：正则写起来很方便 ; 有限状态机写起来成本比较高，还需要一定的设计

### LL LR：字符串多层级结构分析

- 说明：在简单的匹配和分析的基础上，要字符串建立起多层级结构
- LR：比 LL 更强大的语法分析，但因为 LR 理论性比较强，所以通常简单写就用 LL
- eg：HTML 的语法分析用了 stack 去处理，其实就是 LR 算法的简化版 —— LR(0) 的语法
- 一般来说，处理时会用 LR(1)，是可以等于到 LL(n) 的非常强大的分析算法

## 第二小节： 字典树

### 思路 & 步骤

图：图中 4 个字符串构建后的字典树就是图中下面部分

![](https://api2.mubu.com/v3/document_image/25cac528-dbaa-438a-912f-387ba5a9acaf-1434819.jpg)

#### 构建字典树

初始化

插入

结束

#### 截止符

Symbol

#### 验证

插入

![](https://api2.mubu.com/v3/document_image/6de049ef-6f48-4d53-ad37-fe0be3ebe913-1434819.jpg)

统计出现次数最多字符串

![](https://api2.mubu.com/v3/document_image/98d165af-8660-48cd-8724-07bfcf72cbdb-1434819.jpg)

![](https://api2.mubu.com/v3/document_image/0affa0f1-bd6c-44a6-9e1a-34e514f8cfc5-1434819.jpg)

## 第三小节：KMP

### 匹配

图

![](https://api2.mubu.com/v3/document_image/9ac35378-86c3-4c8b-86ac-bf53deed8e50-1434819.jpg)

- 思路一：暴力算法 —— 每一项进行匹配
- 思路二：如何利用之前已经匹配的结论，当遇到不匹配时，则从第一个不匹配的地方重新开始

### 关键点：关注字符串的自重复行为

- 逐一截短
- 查找公共最长子串

![](https://api2.mubu.com/v3/document_image/4de08302-1562-4d74-8dd0-a101b320fba9-1434819.jpg)

表格形式描述

![](https://api2.mubu.com/v3/document_image/5596fcfb-e21b-4c7f-ae45-26f645a267b1-1434819.jpg)

## 第四小节：wildcard

### 分析

- 只含有 \* 的 wildcard 可以看做多个 kmp
- 带 \* 又带 ? 的有点复杂
- 单纯使用正则可以实现 wildcard 但是性能不达标
- 分段使用正则，可以接受
